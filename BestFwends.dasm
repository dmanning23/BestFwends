
	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; We're going to set the player's coarse and fine position
; at the same time using a clever method.
; We divide the X coordinate by 15, in a loop that itself
; is 15 cycles long. When the loop exits, we are at
; the correct coarse position, and we set RESP0.
; The accumulator holds the remainder, which we convert
; into the fine position for the HMP0 register.
; This logic is in a subroutine called SetHorizPos.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SpriteHeight	equ 14*4

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

    seg.u Variables
    org $80

XPos1		.byte
YPos1		.byte
XPos2		.byte
YPos2		.byte
counter .byte

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment

    seg Code
    org $f000

Start
    CLEAN_START
    
    ; set to quad
    lda #7
    sta NUSIZ0
    sta NUSIZ1

    lda #0
    sta REFP0
    sta REFP1
    sta RESP0
    sta RESP1
    sta HMP0
    sta HMP1

    ;set the player 1 x position, right side of screen
    lda #0
    sta YPos1
    sta XPos1

    ;set the player 2 x position, left side of screen
    lda #128
    sta YPos2
    sta XPos2

NextFrame
    lsr SWCHB	; test Game Reset switch
    bcc Start	; reset?

    ; 1 + 3 lines of VSYNC
    VERTICAL_SYNC

    ; 35 lines of underscan
    TIMER_SETUP 35
    
    lda #0
    sta RESP0
    sta RESP1
    sta HMP0
    sta HMP1

    ; animate X and Y coordinates
    ; NOTE: when X is too close to the right side,
    ; we risk using an extra scanline
    inc XPos1
    inc YPos1
    dec XPos2
    dec YPos2
    inc counter

    ;Since we are only drawing one player per frame, which one needs to have x pos set?
    lda counter
    and #$01      ; Mask with 1 to isolate least significant bit
    beq SetP2Horiz

    ;Set the x position of the first player
SetP1Horiz
    lda XPos1
    ldx #0
    jsr SetHorizPos
    lda XPos1
    ldx #1
    jsr SetHorizPos
    jmp DoneSetHorizPos

    ;Set the x position of the 2nd player
SetP2Horiz
    lda XPos2
    ldx #0
    jsr SetHorizPos
    lda XPos2
    ldx #1
    jsr SetHorizPos

DoneSetHorizPos
    sta WSYNC	; sync w/ scanline
    sta HMOVE	; apply fine offsets

    TIMER_WAIT

    ; 192 lines of frame

    ;Which player is being drawn this frame?
    lda counter
    and #$01
    beq DrawP2

DrawP1
    ldx #192	; X = 192 scanlines
LVScan1
    txa		; X -> A
    sec		; set carry for subtract
    sbc YPos1	; local coordinate
    cmp #SpriteHeight ; in sprite?
    bcc InSprite1	; yes, skip over next
    lda #0		; not in sprite, load 0
InSprite1
    lsr        ; Shift right (divide by 2)
    lsr        ; Shift right again (divide by 4)
    tay		; local coord -> Y

    lda Sonic1,y	; lookup color
    sta WSYNC	; sync w/ scanline
    sta GRP0	; store bitmap
    lda Sonic1Color,y ; lookup color
    sta COLUP0	; store color

    lda Sonic2,y	; lookup color
    sta GRP1	; store bitmap
    lda Sonic2Color,y ; lookup color
    sta COLUP1	; store color

    dex		; decrement X
    bne LVScan1	; repeat until 192 lines
    jmp OverScan

DrawP2
    ldx #192	; X = 192 scanlines
LVScan2
    txa		; X -> A
    sec		; set carry for subtract
    sbc YPos2	; local coordinate
    cmp #SpriteHeight ; in sprite?
    bcc InSprite2	; yes, skip over next
    lda #0		; not in sprite, load 0
InSprite2
    lsr        ; Shift right (divide by 2)
    lsr        ; Shift right again (divide by 4)
    tay		; local coord -> Y

    lda Tails1,y	; lookup color
    sta WSYNC	; sync w/ scanline
    sta GRP0	; store bitmap
    lda Tails1Color,y ; lookup color
    sta COLUP0	; store color

    lda Tails2,y	; lookup color
    sta GRP1	; store bitmap
    lda Tails2Color,y ; lookup color
    sta COLUP1	; store color

    dex		; decrement X
    bne LVScan2	; repeat until 192 lines

OverScan
	
; 29 lines of overscan
    TIMER_SETUP 29
    lda $0 ;dont draw the sprite in the overscan
    sta GRP0
    sta COLUP0
    sta GRP1
    sta COLUP1
    TIMER_WAIT
    ; total = 262 lines, go to next frame
    jmp NextFrame

; SetHorizPos routine
; A = X coordinate
; X = player number (0 or 1)
SetHorizPos
	sta WSYNC	; start a new line
	sec		; set carry flag
DivideLoop
	sbc #15		; subtract 15
	bcs DivideLoop	; branch until negative
	eor #7		; calculate fine offset
	asl
	asl
	asl
	asl
	sta RESP0,x	; fix coarse position
	sta HMP0,x	; set fine offset
	rts		; return to caller

;Sonci graphics data
Sonic1
  .byte %00000000 ; Row 1
  .byte %00000000 ; Row 2
  .byte %00000000 ; Row 3
  .byte %01000100 ; Row 4
  .byte %00000000 ; Row 5
  .byte %00101000 ; Row 6
  .byte %00100000 ; Row 7
  .byte %00111000 ; Row 8
  .byte %00100000 ; Row 9
  .byte %01101000 ; Row 10
  .byte %11101000 ; Row 11
  .byte %01001000 ; Row 12
  .byte %11111100 ; Row 13
  .byte %00000000 ; Row 14
  
Sonic2
  .byte %00000000 ; Row 1
  .byte %00000000 ; Row 2
  .byte %00000000 ; Row 3
  .byte %00101000 ; Row 4
  .byte %00101000 ; Row 5
  .byte %00000000 ; Row 6
  .byte %00011000 ; Row 7
  .byte %00000000 ; Row 8
  .byte %00011100 ; Row 9
  .byte %00010100 ; Row 10
  .byte %00010100 ; Row 11
  .byte %00110100 ; Row 12
  .byte %00000000 ; Row 13
  .byte %00000000 ; Row 14

Sonic1Color
  .byte $00 ; Row 1
  .byte $86 ; Row 2
  .byte $86 ; Row 3
  .byte $38 ; Row 4
  .byte $86 ; Row 5
  .byte $88 ; Row 6
  .byte $88 ; Row 7
  .byte $88 ; Row 8
  .byte $88 ; Row 9
  .byte $88 ; Row 10
  .byte $88 ; Row 11
  .byte $88 ; Row 12
  .byte $88 ; Row 13
  .byte $00 ; Row 14

Sonic2Color
  .byte $00 ; Row 1
  .byte $00 ; Row 2
  .byte $38 ; Row 3
  .byte $0E ; Row 4
  .byte $38 ; Row 5
  .byte $FC ; Row 6
  .byte $FC ; Row 7
  .byte $FC ; Row 8
  .byte $FC ; Row 9
  .byte $C8 ; Row 10
  .byte $0E ; Row 11
  .byte $86 ; Row 12
  .byte $00 ; Row 13
  .byte $00 ; Row 14

;Tails graphics data
Tails1
  .byte %00000000 ; Row 1
  .byte %00000000 ; Row 2
  .byte %00000000 ; Row 3
  .byte %00100010 ; Row 4
  .byte %00000000 ; Row 5
  .byte %00010100 ; Row 6
  .byte %11110000 ; Row 7
  .byte %11011100 ; Row 8
  .byte %00010000 ; Row 9
  .byte %00110100 ; Row 10
  .byte %00110100 ; Row 11
  .byte %00100100 ; Row 12
  .byte %00111110 ; Row 13
  .byte %00101000 ; Row 14

Tails2
  .byte %00000000 ; Row 1
  .byte %00000000 ; Row 2
  .byte %00000000 ; Row 3
  .byte %00010100 ; Row 4
  .byte %00010100 ; Row 5
  .byte %00000000 ; Row 6
  .byte %00001100 ; Row 7
  .byte %00000000 ; Row 8
  .byte %11001110 ; Row 9
  .byte %00001010 ; Row 10
  .byte %00001010 ; Row 11
  .byte %00011010 ; Row 12
  .byte %00000000 ; Row 13
  .byte %00000000 ; Row 14

Tails1Color
  .byte $00 ; Row 1
  .byte $86 ; Row 2
  .byte $2E ; Row 3
  .byte $38 ; Row 4
  .byte $2E ; Row 5
  .byte $2E ; Row 6
  .byte $2E ; Row 7
  .byte $2E ; Row 8
  .byte $2E ; Row 9
  .byte $2E ; Row 10
  .byte $2E ; Row 11
  .byte $2E ; Row 12
  .byte $2E ; Row 13
  .byte $2E ; Row 14

Tails2Color
  .byte $00 ; Row 1
  .byte $00 ; Row 2
  .byte $38 ; Row 3
  .byte $0E ; Row 4
  .byte $38 ; Row 5
  .byte $FC ; Row 6
  .byte $0E ; Row 7
  .byte $0E ; Row 8
  .byte $0E ; Row 9
  .byte $88 ; Row 10
  .byte $0E ; Row 11
  .byte $2C ; Row 12
  .byte $00 ; Row 13
  .byte $00 ; Row 14
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue

	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector
